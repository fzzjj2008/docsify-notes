# ch12 并发编程

**并发和并行**

- 并发（Concurrency）：只要时间上重叠就算并发，可以是单处理器交替处理
- 并行（Parallel）：属于并发的一种特殊情况（真子集），多核/多 CPU 同时处理

echo服务器问题（没有**应用级并发**能力）

- accept()函数等待连接请求，一次只能处理一个客户端的请求。慢速客户端会独占服务器影响其他客户端
- 不能充分利用CPU能力，CPU空闲期间处理其他进程
- 不能同时处理多个任务
- 不具备多核能力，无法并行计算

## 12.1 基于进程的并发编程

- 思路：请求到达后，父进程派生出一个子进程，处理新的连接

【例】echo服务器优化

```clike
#include "csapp.h"
void echo(int connfd);

void sigchld_handler(int sig) {
    while (waitpid(-1, 0, WNOHANG) > 0);
}

int main(int argc, char **argv) {
    int listenfd, connfd;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;

    if (argc != 2) {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(0);
    }

    Signal(SIGCHLD, sigchld_handler);
    listenfd = Open_listenfd(argv[1]);
    while (1) {
        clientlen = sizeof(struct sockaddr_storage);
        connfd = Accept(listenfd, (SA *) &clientaddr, &clientlen);
        if (Fork() == 0) {
            Close(listenfd); /* Child closes its listening socket */
            echo(connfd);    /* Child services client */
            Close(connfd);   /* Child closes connection with client */
            exit(0);         /* Child exits */
        }
        Close(connfd); /* Parent closes connected socket (important!) */
    }
}
```

【说明】

- 优点：进程有独立的地址空间，可以消除内存覆盖之类的错误
- 缺点：独立的地址空间导致进程间共享数据流较困难，要使用IPC机制。且IPC开销高，故比较慢

## 12.2 基于I/O多路复用的并发编程

- **IO多路复用**：使用`select()`等函数，要求内核挂起进程，只有在一个或多个**I/O事件发生后，才将控制返回**给应用程序

- **事件驱动**：借助`select()`函数检测输入事件发生，然后事件转移给事件池中做进一步处理

![image-20230116072517034](https://cdn.docjerry.top/csapp/image-20230116072517034.png)

【例】[基于I/O多路复用的并发事件驱动服务器](https://github.com/fzzjj2008/fzzjj2008.github.io/tree/main/docs/csapp/echo_select)

```clike
#include "csapp.h"

typedef struct { /* Represents a pool of connected descriptors */
    int maxfd;        /* Largest descriptor in read_set */   
    fd_set read_set;  /* Set of all active descriptors */
    fd_set ready_set; /* Subset of descriptors ready for reading  */
    int nready;       /* Number of ready descriptors from select */
    int maxi;         /* Highwater index into client array */
    int clientfd[FD_SETSIZE];    /* Set of active descriptors */
    rio_t clientrio[FD_SETSIZE]; /* Set of active read buffers */
} pool;

void init_pool(int listenfd, pool *p);
void add_client(int connfd, pool *p);
void check_clients(pool *p);

int byte_cnt = 0; /* Counts total bytes received by server */

int main(int argc, char **argv) {
    int listenfd, connfd;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;
    static pool pool;

    if (argc != 2) {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(0);
    }
    listenfd = Open_listenfd(argv[1]);
    init_pool(listenfd, &pool);

    while (1) {
        /* Wait for listening/connected descriptor(s) to become ready */
        pool.ready_set = pool.read_set;
        pool.nready = Select(pool.maxfd+1, &pool.ready_set, NULL, NULL, NULL);

        /* If listening descriptor ready, add new client to pool */
        if (FD_ISSET(listenfd, &pool.ready_set)) {
            clientlen = sizeof(struct sockaddr_storage);
            connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen);
            add_client(connfd, &pool);
        }

        /* Echo a text line from each ready connected descriptor */
        check_clients(&pool);
    }
}

void init_pool(int listenfd, pool *p) {
    /* Initially, there are no connected descriptors */
    int i;
    p->maxi = -1;
    for (i=0; i< FD_SETSIZE; i++)
        p->clientfd[i] = -1;

    /* Initially, listenfd is only member of select read set */
    p->maxfd = listenfd;
    FD_ZERO(&p->read_set);
    FD_SET(listenfd, &p->read_set);
}

void add_client(int connfd, pool *p) {
    int i;
    p->nready--;
    for (i = 0; i < FD_SETSIZE; i++) { /* Find an available slot */
        if (p->clientfd[i] < 0) {
            /* Add connected descriptor to the pool */
            p->clientfd[i] = connfd;
            Rio_readinitb(&p->clientrio[i], connfd);

            /* Add the descriptor to descriptor set */
            FD_SET(connfd, &p->read_set);

            /* Update max descriptor and pool highwater mark */
            if (connfd > p->maxfd)
                p->maxfd = connfd;
            if (i > p->maxi)
                p->maxi = i;
            break;
        }
    }
    if (i == FD_SETSIZE) /* Couldn't find an empty slot */
        perror("add_client error: Too many clients");
}

void check_clients(pool *p) {
    int i, connfd, n;
    char buf[MAXLINE];
    rio_t rio;

    for (i = 0; (i <= p->maxi) && (p->nready > 0); i++) {
        connfd = p->clientfd[i];
        rio = p->clientrio[i];

        /* If the descriptor is ready, echo a text line from it */
        if ((connfd > 0) && (FD_ISSET(connfd, &p->ready_set))) {
            p->nready--;
            if ((n = Rio_readlineb(&rio, buf, MAXLINE)) != 0) {
                byte_cnt += n;
                printf("Server received %d (%d total) bytes on fd %d\n", n, byte_cnt, connfd);
                Rio_writen(connfd, buf, n);
            }

            /* EOF detected, remove descriptor from pool */
            else {
                Close(connfd);
                FD_CLR(connfd, &p->read_set);
                p->clientfd[i] = -1;
            }
        }
    }
}
```

【说明】

- 优点：相比进程和线程的方式，有明显的性能优势。单进程不需要进程上下文切换调度新的流
- 缺点：编码复杂，不能充分利用多核处理器

## 12.3 基于线程的并发编程

- **线程模型**：与多进程模型类似，但运行在单一进程的上下文中，共享进程虚拟地址空间的所有内容（代码、数据、堆、共享库、打开文件）。线程的上下文比进程上下文轻量得多，切换开销小

![image-20230116072539127](https://cdn.docjerry.top/csapp/image-20230116072539127.png)

- **POSIX线程常用方法**

```clike
typedef void *(func)(void *);
int pthread_create(pthread_t *tid, pthread_attr_t *attr, func *f, void *arg);
pthread_t pthread_self(void);
pthread_exit(void *thread_return);
int pthread_cancel(pthread_t tid);
int pthread_join(pthread_t tid, void **thread_return);
int pthread_detach(pthread_t tid);

// 初始化与线程例程相关的状态
pthread_once_t once_control = PTHREAD_ONCE_INIT;
int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));
```

【例】基于线程的并发echo服务器

```clike
#include "csapp.h"

void echo(int connfd);
void *thread(void *vargp);

int main(int argc, char **argv) {
    int listenfd, *connfdp
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;
    pthread_t tid;

    if (argc != 2) {
        fprintf(stderr, "usage: %s <pott>\n", argv[0]);
        exit(0);
    }
    listenfd = open_listenfd(argv[1]);

    while (1) {
        clientlen = sizeof(struct sockaddr_storage);
        connfd = malloc(sizeof(int));
        *connfdp = accept(listenfd, (SA *) &clientaddr, &clientlen);
        pthread_create(&tid, NULL, thread, connfdp);
    }
}

/* Thread routine */
void *thread(void *vargp) {
    int connfd = *((int *)vargp);
    pthread_detach(pthread_self());
    free(vargp);
    echo(connfd);
    close(connfd);
    return NULL;
}
```

【说明】

- 优点：可以方便共享数据流，且能够充分利用多核
- 缺点：引入**竞争（race）**，需要小心处理内存泄露问题（12.5节优化）

## 12.4 线程内存模型

- **独立部分**：**线程上下文**，包括：线程ID、栈、栈指针、程序计数器、条件码、通用目的寄存器。
- **共享部分**：进程上下文的剩余部分，包括：**虚拟地址空间**（代码段、数据段、堆、共享库代码和数据区域）；进程**打开文件的集合**

```clike
#include <stdio.h>
#include <pthread.h>
#define N 2
void *thread(void *vargp);

char **ptr;  /* Global variable */

int main() {
    int i;
    pthread_t tid;
    char *msgs[N] = {
        "Hello from foo",
        "Hello from bar"
    };
    ptr = msgs;
    for (i = 0; i < N; i++) {
        pthread_create(&tid, NULL, thread, (void *)i);
    }
    pthread_exit(NULL);
}

void *thread(void *vargp) {
    int myid = (int *)vargp;
    static int cnt = 0;
    printf("[%d]: %s (cnt = %d)\n", myid, ptr[myid], ++cnt);
    return NULL;
}
```

【说明】

- **全局变量**：任何线程都可以引用，如`char **ptr;`
- **局部变量**：每个线程有自己的实例，如`int myid;`
- **静态变量**：任何线程都可以引用，如`static int cnt;`

## 12.5 信号量同步线程

### 12.5.1 同步错误

【例】下面两个线程同时操作共享计数变量引入问题

```clike
/* WARNING: This code is buggy! */
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

void *thread(void *vargp);

/* Global shared variable */
volatile long cnt = 0; /* Counter */

int main(int argc, char **argv) {
    long niters;
    pthread_t tid1, tid2;

    /* Check input argument */
    if (argc != 2) {
        printf("usage: %s <niters>\n", argv[0]);
        exit(0);
    }
    niters = atoi(argv[1]);

    /* Create threads and wait for them to finish */
    pthread_create(&tid1, NULL, thread, &niters);
    pthread_create(&tid2, NULL, thread, &niters);
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);

    /* Check result */
    if (cnt != (2 * niters)) {
        printf("BOOM! cnt = %ld\n", cnt);
    } else {
        printf("OK! cnt = %ld\n", cnt);
    }
    return 0;
}

void *thread(void *vargp) {
    long i, niters = *((long *)vargp);
    for (i = 0; i < niters; i++) {
        cnt++;
    }
    return NULL;
}
```

【测试】会得到错误的结果：

```bash
# ./badcnt 1000000
BOOM! cnt = 1191418
```

【分析】将for循环核心代码进行反汇编，得到：

```clike
// void *thread(void *vargp)
// vargp in %rdi, cnt in %rax
thread:
        movq    (%rdi), %rcx        // H: niters = %rcx
        movl    $0, %edx            // H: i = %rdx
.L2:
        cmpq    %rcx, %rdx
        jge     .L4
        movq    cnt(%rip), %rax     // L: 加载cnt
        addq    $1, %rax            // U: 更新cnt
        movq    %rax, cnt(%rip)     // S: 存储cnt
        addq    $1, %rdx            // T: i++
        jmp     .L2
.L4:
        movl    $0, %eax
        ret
```

- 书中为方便描述，将汇编代码划分为5个阶段。其中更新`cnt`操作（即**临界区**的操作）并不是**原子操作**，而是由3个阶段组成（L、U、S）。对临界区的指令，如果线程1执行更新`cnt`的过程被线程2打断，就会导致错误的结果

==图12-18==

- 为了更直观的呈现，两个线程执行的**进度图**如12-21所示。只要执行轨迹穿过了不安全的区域，就会导致**竞争**的出现，导致错误的结果

==图12-21==

### 12.5.2~12.5.3 信号量

Dijkstra提出了一种经典方法，基于**信号量**的特殊变量来解决了同步错误

- **信号量（`semaphore`）**：非负整数值的全局变量，包含两种特殊操作：
  - `P(s)`：若`s`非负，将`s`减一；如果`s`为0，则挂起线程，直到V操作将线程唤醒
  - `V(s)`：将`s`加一。一旦`s`变成非0，将唤醒一个线程，使之完成P操作

```clike
#include <semaphore.h>

int sem_init(sem_t *sem, 0, unsigned int value);
int sem_wait(sem_t *s);    /* P(s) */
int sem_post(sem_t *s);    /* V(s) */
```

修改12.5.1中的例程，增加信号量操作，可以获得正确的结果

```clike
sem_t mutex;

int main(int argc, char **argv) {
    sem_init(&mutex, 0, 1);
......    
}

void *thread(void *vargp) {
    long i, niters = *((long *)vargp);
    for (i = 0; i < niters; i++) {
        sem_wait(&mutex);
        cnt++;
        sem_post(&mutex);
    }
    return NULL;
}
```

### 12.5.4 一些示例

【例】生产者消费者（使用shared FIFO buffer实现）

- 临界区：有限空间
- 生产者：向临界区增加东西
- 消费者：从临界区消费东西

```clike
#include "csapp.h"

typedef struct {
    int *buf;          /* 数组结构，其长度由用户确定，在sbuf_init函数中进行内存分配 */         
    int n;             /* 数组的最大长度，也就是循环队列的容量 */
    int front;         /* 队首指针，buf[(front+1)%n] 是循环队列的第一个元素 */
    int rear;          /* 队尾指针，buf[rear%n] 是循环队列的最后一个元素 */
    sem_t mutex;       /* Protects accesses to buf */
    sem_t slots;       /* Counts available slots */
    sem_t items;       /* Counts available items */
} sbuf_t;

/* Create an empty, bounded, shared FIFO buffer with n slots */
/* $begin sbuf_init */
void sbuf_init(sbuf_t *sp, int n)
{
    sp->buf = Calloc(n, sizeof(int)); 
    sp->n = n;                       /* Buffer holds max of n items */
    sp->front = sp->rear = 0;        /* Empty buffer iff front == rear */
    Sem_init(&sp->mutex, 0, 1);      /* Binary semaphore for locking */
    Sem_init(&sp->slots, 0, n);      /* Initially, buf has n empty slots */
    Sem_init(&sp->items, 0, 0);      /* Initially, buf has zero data items */
}
/* $end sbuf_init */

/* Clean up buffer sp */
/* $begin sbuf_deinit */
void sbuf_deinit(sbuf_t *sp)
{
    Free(sp->buf);
}
/* $end sbuf_deinit */

/* Insert item onto the rear of shared buffer sp */
/* $begin sbuf_insert */
void sbuf_insert(sbuf_t *sp, int item)
{
    P(&sp->slots);                          /* Wait for available slot */
    P(&sp->mutex);                          /* Lock the buffer */
    sp->buf[(++sp->rear)%(sp->n)] = item;   /* 在队尾插入元素，并将队尾指针后移 */
    V(&sp->mutex);                          /* Unlock the buffer */
    V(&sp->items);                          /* Announce available item */
}
/* $end sbuf_insert */

/* Remove and return the first item from buffer sp */
/* $begin sbuf_remove */
int sbuf_remove(sbuf_t *sp)
{
    int item;
    P(&sp->items);                          /* Wait for available item */
    P(&sp->mutex);                          /* Lock the buffer */
    item = sp->buf[(++sp->front)%(sp->n)];  /* 从队首取出元素，并将队首指针后移 */
    V(&sp->mutex);                          /* Unlock the buffer */
    V(&sp->slots);                          /* Announce available slot */
    return item;
}
```

【例】第一类读者-写者问题（读者优先级高于写者）

- 读操作：允许多个读操作，读期间不允许写
- 写操作：允许一个写操作，写期间不允许读

```clike
int readcnt = 0;
sem_t mutex; // 保护 readcnt
sem_t w;     // 读者或写者抢占 w

void init() {
    sem_init(&mutex, 0, 1);
    sem_init(&w, 0, 1);
}

void reader() {
    while(1) {
        sem_wait(&mutex);
        readcnt++;
        if(readcnt == 1)
            sem_wait(&w); // 如果这是第一个读者，抢占 w
        sem_post(&mutex);
      
        // Critical section
        // Reading...
      
        sem_wait(&mutex);
        readcnt--;
        if(readcnt == 0)
            sem_post(&w); // 如果这是最后一个读者，释放 w
        sem_post(&mutex);
    }
}

void writer() {
    while(1) {
        sem_wait(&w);
            
        // Critical section
        // Writing...
        
        sem_post(&w);
    }
}
```

【例】[基于预线程化的并发服务器](https://github.com/fzzjj2008/fzzjj2008.github.io/tree/main/docs/csapp/echo_thread)

==12-27==

## 12.6 使用线程提高并行性

<font color='red'>充分利用多核的特性，可以显著提升性能，但注意尽可能避免同步操作的开销</font>

【例】书中例子，用四核处理器对$2^{31}$个元素序列求和

```clike
// 加锁操作全局变量
void* sum_mutex(void* vargp) {
    // 根据 vargp 确定计算范围
    for (i = start; i < end; i++) {
        sem_wait(&mutex);
        gsum += i;
        sem_post(&mutex);
    }
    return NULL;
}

// 每个线程独立位置存放结果，无需 mutex，直接累加到全局数组。主线程等待所有子线程完成
void* sum_global(void* vargp) {
    // 根据 vargp 确定计算范围
    long threadId = *((long*) vargp);
    for(i=start; i<end; i++)
        gsum[threadId] += i;
    return NULL;
}

// 先用局部变量累加结果，减少不必要的内存引用，最后一次性赋给全局数组
void* sum_local(void* vargp) {
    // 根据 vargp 确定计算范围
    int local_sum = 0;
    for(i=start; i<end; i++) {
        local_sum += i;
    }
    gsum[threadId] = local_sum;
    return NULL;
}
```

【性能】`sum_local` > `sum_global` > `sum_mutex`

## 12.7 其他并发问题

### 12.7.1 线程安全

- **线程安全**：