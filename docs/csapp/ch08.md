# ch08 异常控制流

## 8.1 异常

- **控制流**：处理器加电到断电为止，程序计数器会执行一串的指令序列，称为处理器的控制流

- **异常**：控制流中的突变，用来响应处理器状态的某些变化
  - 异常事件发生（比如虚拟内存缺页、除以零等），处理器跳转到异常表执行异常处理程序
  - 处理完成后，发生3种情况：
    - 处理程序将控制返回当前正在执行的指令$I_{curr}$
    - 处理程序将控制返回下一条指令$I_{next}$
    - 处理程序终止被中断的程序

![image-20221229082955110](http://cdn.docjerry.top/csapp/image-20221229082955110.png)

### 8.1.1 异常处理

【过程】

- 程序运行时，处理器检测到异常事件发生，并确定*异常号$k$*
- **异常表基址寄存器**和异常号加权，获取**异常处理程序的起始地址**
- 执行异常处理程序

![image-20221229082313337](http://cdn.docjerry.top/csapp/image-20221229082313337.png)

> [!NOTE]
>
> **异常和函数调用的区别**
>
> - 函数调用将下一条PC压入用户栈中；异常根据类型，将返回地址（当前指令或下一条指令）压入栈中，还会将额外信息（即进程上下文信息，如EFLAGS等）压入栈中
> - 如果控制从用户态陷入内核态，上下文被压入内核栈中，而不是用户栈
> - 异常处理程序运行在内核态，对系统所有资源都有完全的访问权限



### 8.1.2 异常的类别

<font color='red'>中断（interrupt）、陷阱（trap）、故障（fault）、终止（abort）</font>

![image-20221229083534104](http://cdn.docjerry.top/csapp/image-20221229083534104.png)

- **中断**：来自**外部IO设备的信号**（比如键盘事件）。**当前指令执行完成后，处理器注意到中断引脚的电压变高，就从系统总线读取异常号，调用适当的中断处理程序**。处理程序返回，执行**下一条指令**

![image-20221229085439386](http://cdn.docjerry.top/csapp/image-20221229085439386.png)

- **陷阱**：执行指令产生的异常，最重要的用途是**系统调用syscall**（如read、fork等）。执行完syscall后继续执行控制流的下一条指令

![image-20221229085453908](http://cdn.docjerry.top/csapp/image-20221229085453908.png)

- **故障**：错误情况引起，可能**被故障处理程序修正，并重新执行**（如缺页中断）。若无法修正则终止

![image-20221229085511754](http://cdn.docjerry.top/csapp/image-20221229085511754.png)

- **终止**：不可恢复的致命错误，最终终止这个应用程序



### 8.1.3 Linux/x86-64系统中的异常

- **异常号**：0\~31由Intel架构师定义，32\~255由操作系统定义。常见异常如图8-9
  - 0：除零异常，程序终止
  - 13：即段错误，程序终止
  - 14：缺页异常，内核尝试恢复（详见第9章）

![image-20221229085624365](http://cdn.docjerry.top/csapp/image-20221229085624365.png)

- **系统调用**：应用程序通过系统调用访问系统的资源，常见的系统调用如图8-10
  - 系统调用的参数最多6个，都是通过**寄存器传递**的

![image-20221229091752131](http://cdn.docjerry.top/csapp/image-20221229091752131.png)

【例】打印hello world

```clike
#include <unistd.h>

int main() {
    write(1, "hello world\n", 12);
    _exit(0);
}
```

【编译】

```clike
.LC0:
        .string "hello world\n"
main:
        subq    $8, %rsp
        movl    $12, %edx          //write(1, "hello world\n", 12);
        movl    $.LC0, %esi
        movl    $1, %edi
        call    write
        movl    $0, %edi           //_exit(0);
        call    _exit
```



## 8.2 进程

用户在使用shell执行可执行文件，shell会创建一个新的进程，然后在进程的上下文中运行可执行文件。这里涉及到两个概念：

- **进程（process）**：一个执行中程序的实例
- **上下文（context）**：保存进程运行的状态，包括程序的代码段、数据段、栈、通用寄存器、程序计数器、环境变量、打开的文件描述符



![image-20221231114906163](http://cdn.docjerry.top/csapp/image-20221231114906163.png)
