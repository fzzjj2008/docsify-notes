# ch10 系统级I/O

## 10.1~10.4 读写文件

- **文件（`file`）**：字节的序列。所有的IO设备都可以模型化为文件，输入输出作为读和写来执行
  - **打开文件**：应用程序通过`open`打开文件，内核返回一个非负整数（**文件描述符**）。其中，每个进程都有3个特殊的文件描述符：标准输入(`STDIN_FILENO`)、标准输出(`STDOUT_FILENO`)、标准错误(`STDERR_FILENO`)，定义在<unistd.h>下
  - **读写文件**：复制n个字节到内存；从内存复制n个字节到文件
  - **关闭文件**：内核释放打开文件创建的数据结构，释放内存资源和文件描述符
- **普通文件（`regular file`）**：分文本文件（`text file`）和二进制文件（`binary file`）。对内核而言两者没有区别
- **目录（`directory`）**：包含一组链接的文件，每个链接映射到另一个文件或目录。其中，每个目录包含2个特殊文件：当前目录（`.`）、父目录（`..`）
- **套接字（`socket`）**：与另一个进程跨网络通信的文件
- **其它文件类型**：命名管道、符号链接、字符设备、块设备等

【例】读文件例程。为了简单起见，忽略了异常处理

```clike
#include <unistd.h>
#include <fcntl.h>

#define BUF_SIZE 1024

int main() {
    int fd;
    ssize_t nRead;
    char buf[BUF_SIZE];

    fd = open("foo.txt", O_RDONLY, 0);
    while ((nRead = read(fd, buf, BUF_SIZE)) > 0) {
        write(STDOUT_FILENO, buf, nRead);
    }
    close(fd);
}
```

## 10.5 RIO

- RIO(Robust I/O)：健壮的I/O包，处理

```clike
#include <stdio.h>
#include <unistd.h>
#include <sys/stat.h>

int main(int argc, char *argv[]) {
    struct stat st;
    char *type, *readok;

    stat(argv[1], &st);
    if (S_ISREG(st.st_mode))    /* Determine file type */
        type = "regular";
    else if (S_ISDIR(st.st_mode))
        type = "directory";
    else
        type = "other";
    if ((st.st_mode & S_IRUSR)) /* Check read access */
        readok = "yes";
    else
        readok = "no";
    printf("type: %s, read: %s\n", type, readok);
    return 0;
}
```

```clike
#include <stdio.h>
#include <dirent.h>

int main(int argc, char *argv[]) {
    DIR *streamp;
    struct dirent *dep;

    streamp = opendir(argv[1]);
    while ((dep = readdir(streamp)) != NULL) {
        printf("%s\n", dep->d_name);
    }
    closedir(streamp);
    return 0;
}
```