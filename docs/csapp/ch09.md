# ch09 虚拟内存

## 9.1 物理和虚拟寻址

- **物理地址**：计算机的主存被组织成连续的字节单元组成的数组。每个字节都有唯一的物理地址
- **物理寻址**：CPU使用物理地址直接访问内存的方式
- **虚拟地址**：主存进行抽象，为每个进程提供大小一致的、私有的地址空间
- **虚拟寻址**：CPU通过一个虚拟地址访问内存，虚拟地址通过**地址翻译**转化为适当的物理地址

![image-20230104212756659](https://cdn.docjerry.top/csapp/image-20230104212756659.png)

## 9.2 地址空间

- **地址空间（address space）**：非负整数地址的有序集合
- **线性地址空间**：地址空间的整数是连续的。为了简化讨论，总是假设是线性的
- **物理地址空间**：由$M$个字节的物理内存组成的地址空间。这里$M$不要求是2的幂
$$
\{0,1,2,...,M-1\}
$$
- **虚拟地址空间**：每个进程由$2^n$个字节组成的虚拟地址空间。其中$n$表示32位或64位系统
$$
\{0,1,2,...,2^n-1\}
$$

## 9.3~9.5 虚拟页

- **虚拟页VP（简称页, page）**：虚拟内存分割成固定大小的块。页大小是$P=2^p$字节，Linux中默认是4096字节（`getconf PAGESIZE`）
- **物理页PP（简称页帧, page frame）**：物理内存分割成固定大小的块。页帧大小是$P=2^p$字节
- **页表（Page Table）**：虚拟页通过页表的数据结构映射到物理页。页表由**页表项（PTE, Page Table Entry）** 组成
  - **页表项**：包含页帧地址以及控制位，控制位包含 **有效位(valid bit)** 表明当前虚拟页是否被保存在内存中

![image-20230104220838507](https://cdn.docjerry.top/csapp/image-20230104220838507.png)

【说明】图9-4中的虚拟页面如下：

- `VP0`, `VP5`：还未分配

- `VP1`, `VP2`, `VP4`, `VP7`：已分配，缓存在内存中
- `VP3`, `VP6`：已分配，但是被换出到磁盘上，未缓存在内存里

考虑以下操作：

- **页命中**：如果进程访问`VP2`中的虚拟地址。由于**页表项是有效的**，此时页表将`VP2` **翻译**成物理页帧`PP1`，最后构造出物理地址
- **缺页**：如果进程访问`VP3`中的虚拟地址。由于**页表项无效**，所以引发**缺页异常**。此时内核从磁盘将`VP3`的页帧替换到物理内存中(假设位置是`PP3`)，再将`VP3`翻译成`PP3`，最后构造出物理地址
  - **页面调度算法**：磁盘和内存之间，页面如何换入换出，涉及到**页面调度算法**。良好的调度算法遵循**局部性原理**，避免不断地换入换出（**抖动状态**）
- **分配页面**：比如调用`malloc`将在磁盘上创建空间并更新PTE

虚拟页带来的好处：大大简化了内存管理，并提供了一种自然的保护内存的方法

- 简化链接、加载、代码和数据共享
- 提供页面级的内存保护，允许进程读写某个页面（违反则引发**一般保护故障**，即**段错误**）



## 9.6 地址翻译

### 9.6.1 地址翻译基础知识

**页面映射**：虚拟地址根据虚拟页号，从页表找到对应的索引，进而找到对应的物理页号，加上偏移得到物理地址

![image-20230105230023685](https://cdn.docjerry.top/csapp/image-20230105230023685.png)

**页面命中和缺页的操作**

- **页面命中操作**：查询PTE$\to$MMU构造物理地址$\to$返回内存数据给CPU
  - CPU生成一个虚拟地址，并传送给MMU
  - MMU生成PTE地址，并从高速缓存/主存请求得到它
  - 高速缓存/主存向MMU返回PTE
  - MMU构造物理地址，并把它传送给高速缓存/主存
  - 高速缓存/主存返回所请求的数据字给处理器
- **缺页操作**：查询PTE$\to$**缺页中断$\to$调度页面$\to$更新PTE**$\to$再次执行引起缺页的指令$\to$页面命中操作
  - 同页面命中1~3步，查询PTE
  - PTE的有效位是0，引发缺页异常，中断处理缺页异常处理程序
  - **缺页处理程序根据调度算法，将某个页面换入磁盘**
  - **缺页处理程序根据调度算法，将所需页面换入内存，并更新内存中的PTE**
  - 返回到原来的进程，再次执行引起缺页的指令

![image-20230105232015256](https://cdn.docjerry.top/csapp/image-20230105232015256.png)

> [!NOTE]
>
> 地址翻译时，MMU访问主存，中间可以使用L1、L2、L3高速缓存加速

### 9.6.2 TLB

每次CPU产生虚拟地址，MMU就要查询一次PTE。因此MMU使用TLB加速地址翻译

- **TLB（Translation Lookaside Buffer, 翻译后备缓冲器）**：一个很小的虚拟寻址缓存，每行保存
- **TLB加速翻译的过程**
  - CPU产生虚拟地址，传送给MMU
  - TLB命中，MMU从TLB取出相应的PTE直接返回；TLB不命中，从L1缓存取出TLB，并刷新TLB
  - 后续流程一致

![image-20230105233240773](https://cdn.docjerry.top/csapp/image-20230105233240773.png)

### 9.6.3 多级页表

【问题】对于32位系统，假设页面大小为4KB，PTE大小占4字节，则总是需要有一个`4MB`的页表主存在内存中，**造成内存空间浪费**。对64位系统会更加复杂
$$
\begin{array}{l}
虚拟地址分为2个部分：虚拟页号(20\ bit)+页面偏移(12\ bit) \\
页表大小=2^{20}*4Byte=4MB
\end{array}
$$
【解决】引入**二级页表**管理。假设页面大小是4KB，PTE大小占4字节。则只有一级页表`4KB`常驻内存 + 常用的二级页表`N*4KB`所占的内存。其它二级页表只有在使用时换入内存，从而**大幅节约内存空间**
$$
\begin{array}{l}
虚拟地址分为3个部分：1级页表页号(10\ bit)+2级页表页号(10\ bit)+页面偏移(12\ bit) \\
1级页表大小=2^{10}*4Byte=4KB \\
2级页表大小=2^{10}*4Byte=4KB
\end{array}
$$

- k级页表的地址翻译原理也是类似的。**使用TLB，保证多级页表的翻译不比一级页表慢很多**

![image-20230105235525372](https://cdn.docjerry.top/csapp/image-20230105235525372.png)

### 9.6.4 地址翻译示例

【例】书中例子，定义以下格式小系统

- 内存按字节寻址（不是4字节的字）
- 页面大小是$2^6=64$字节
- 虚拟地址占14位（虚拟页号8bit + 偏移6bit）
- 物理地址占12位（物理页号8bit + 偏移6bit）
- TLB是四路组相联的，总共有16个条目
- L1缓存是物理寻址、直接映射的，行大小为4字节，总共有16个组

**假设当前TLB、页表项、L1缓存的内容如下：**

![image-20230106205122988](https://cdn.docjerry.top/csapp/image-20230106205122988.png)

**此时访问虚拟地址`0x03d4`，过程如下：**

![image-20230106205231478](https://cdn.docjerry.top/csapp/image-20230106205231478.png)

- **第一阶段**：通过TLB或MMU获取物理页号，得到物理地址
  - 虚拟地址：虚拟页号0x0f、偏移0x14
  - 取PTE：检查TLB。将虚拟页号进一步拆成TLB索引(0x3)和TLB标记(0x3)，有效匹配组0x3的第二个条目，将TLB缓存的0x0D返回MMU
    - 注：如果TLB表项无效，则通过虚拟页号(0xF)在页表中也能找到物理页号是0x0D
  - 物理地址：0xD << 6 + 0x14 = 0x354

![image-20230106205252965](https://cdn.docjerry.top/csapp/image-20230106205252965.png)

- **第二阶段**：L1缓存取出数据
  - 物理地址拆成：缓存标记(0x0d)、缓存组索引(0x5)、缓存偏移(0x0)
  - L1缓存找组0x5，此时标记位0xD且有效位为1表示命中。读出偏移量0x00的数据字节为0x36，返回MMU
  - MMU将0x36返回给CPU



## 9.7 Intel Core i7/Linux内存系统

看一下实际的Intel Core i7的内存系统。其实就是前面几节的扩展

- Core i7包括四个核、所有核共享L3高速缓存和DDR3内存控制器

- 每个核包含一个层次结构的TLB（四路组相联）、一个层次结构的数据和指令高速缓存、一组快速的点到点链路（用于核与其他核和外部IO桥直接通信）
- L1、L2、L3是物理寻址的，块大小为64字节。L1和L2是8路组相联、L3是16路组相联的
- Linux系统页大小启动时默认是4KB

![image-20230108105612111](https://cdn.docjerry.top/csapp/image-20230108105612111.png)

### 9.7.1 地址翻译过程

**最长过程**：CPU访问虚拟地址(VA)$\to$TLB(不命中)$\to$MMU地址翻译(四级页表)$\to$更新TLB$\to$拼接物理地址(PA)$\to$Cache查找结果(不命中)$\to$主存查找结果$\to$更新Cache$\to$返回结果给CPU

![image-20230108105859945](https://cdn.docjerry.top/csapp/image-20230108105859945.png)

**MMU四级页表翻译过程**

![image-20230108112611878](https://cdn.docjerry.top/csapp/image-20230108112611878.png)

- 36位虚拟页号分成4个9位的虚拟页号VPN1~VPN4，分别指向各级页表
- CR3寄存器包含1级页表的物理地址。根据VPN1的索引找到页表项L1 PTE
- L1 PTE包含2级页表的物理地址。根据VPN2的索引找到页表项L2 PTE
- 以此类推，找到物理地址PPN

> [!TIP]
>
> 每当触发上下文切换后，就将CR3寄存器（1级页表基地址）更新为`task_struct->mm->pgd`
>
> MMU每翻译一个虚拟地址时，会更新各级页表的A位（访问位）和D位（修改位），用于页面调度算法



### 9.7.2 Linux虚拟内存系统

**Linux为每个进程各自维护了一个虚拟地址空间，分为内核空间和用户空间**

- **用户空间**：代码、数据、堆、共享库、栈段
- **内核空间**：内核代码和数据、进程相关的数据结构（页表、内核栈）等。注意：**Linux进程的内核空间是共享的，直接映射到一组连续的物理页面**

![image-20230108131603715](https://cdn.docjerry.top/csapp/image-20230108131603715.png)

**虚拟内存的组织**：内核为系统的每个进程维护了一个`task_struct`，内部包含进程的所有信息（PID、用户栈指针、可执行目标文件名、程序计数器、虚拟内存状态等）

- `task_struct->mm`：记录虚拟内存的当前状态。其中，我们关心两个条目：
  - `mm->pgd`：指向第一级页表的基址，上下文切换时会更新CR3寄存器
  - `mm->mmap`：指向`vm_area_structs`的链表，链表的各个节点描述了当前虚拟地址空间的一个区域，指示区域的起始和结束位置、该区域是否具有读写权限、是否是共享的

![image-20230108130344902](https://cdn.docjerry.top/csapp/image-20230108130344902.png)

**Linux缺页异常处理**

- 虚拟地址A是否合法？若不合法，触发段错误，终止进程
- 虚拟地址访问的内存区域是否合法（该区域是否有读写权限）？若不合法，触发段错误，终止进程
- 牺牲一个页面，换入新页面
- CPU重新执行引起缺页的指令



## 9.8 内存映射

> [!NOTE]
>
> 本节内容参考《UNIX系统编程手册》

### 9.8.1~9.8.3 内存映射

调用进程使用`mmap()`，可以在虚拟地址空间中创建一个内存映射。映射分为2种：

- **文件映射**：将一个普通文件的一部分直接映射到进程的虚拟内存中。之后可以读取内存字节操作文件内容。映射的分页在需要时从文件中自动加载
- **匿名映射**：没有对应的文件，映射的分页初始化为0

进程间共享分页是否可见又分2种：

- **私有映射（MAP_PRIVATE）**：映射内容的变更对其他进程不可见，进程间通过**写时复制(copy-on-write)**共享
  - **写时复制**：例如发生在`fork()`系统调用时。初始时父子进程共享分页，分页都是只读权限。当有一个进程修改分页内容，在物理内存中创建一个新副本，复制分页内容到新副本中，最后恢复页面的可写权限。CPU在新页面上重新执行写操作
- **共享映射（MAP_SHARED）**：两个进程共享同一个映射区域，其他进程可见。对文件映射来说，变更将发生在底层的文件上。

综上所述，内存映射的方式包含四种，用途如下：

|          | 文件映射                         | 匿名映射            |
| -------- | -------------------------------- | ------------------- |
| 私有映射 | 根据文件内容初始化内存           | 内存分配            |
| 共享映射 | 内存映射I/O：进程间共享内存(IPC) | 进程间共享内存(IPC) |

- **私有文件映射**：多个进程初始时使用相同文件初始化，共享相同的内存分页。通过写时复制使得进程对映射做出的改变对其他进程不可见。**用途**：根据二进制可执行文件或共享库文件的相应部分，初始化一个进程的文本和数据段
- **私有匿名映射**：使用`mmap()`创建一个新映射，各进程间不共享分页。**用途**：为一个进程分配用0填充的内存，如使用`mmap()`分配大块内存；`fork()`之后父子进程不会看到对内存分页做出的变更
- **共享文件映射**：进程共享相同的内存物理分页，对分页的修改直接在文件中进行。**用途**：进程间通信
- **共享匿名映射**：发生在父子进程间，映射的分页不采取写时复制，即父子进程共享相同的RAM分页。**用途**：父子进程间通信

> [!TIP]
>
> 再看`fork()`和`execve()`流程
>
> - `fork()`流程
>   - 内核为子进程创建各种数据结构，并分配唯一PID
>   - 将父子进程的**每个页面都标记为只读**，并将进程中的每个区域结构都标记为**私有的写时复制**
>   - 父进程或子进程进行写操作时，**通过写时复制机制，创建新页面**
> - `execve()`流程
>   - 删除子进程已存在的区域结构
>   - 映射私有区域
>   - 映射共享区域
>   - 设置程序计数器PC，指向代码区域的入口点(main函数)

### 9.8.4 mmap函数

```clike
#include <unistd.h>
#include <sys/mman.h>
//返回：若成功则为指向映射区域的指针，若出错则为MAP_FAILED(-1)
void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
//返回：若成功返回0，出错返回-1
int munmap(void *start, size_t length);
```

【例】



## 9.9 动态内存分配

### 9.9.1 malloc和free函数

```clike
#include <stdlib.h>
void *malloc(size_t size);
void *sbrk(intptr_t incr);
void free(void *ptr);
```



```clike
```

