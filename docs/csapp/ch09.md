# ch09 虚拟内存

## 9.1 物理和虚拟寻址

- **物理地址**：计算机的主存被组织成连续的字节单元组成的数组。每个字节都有唯一的物理地址
- **物理寻址**：CPU使用物理地址直接访问内存的方式
- **虚拟地址**：主存进行抽象，为每个进程提供大小一致的、私有的地址空间
- **虚拟寻址**：CPU通过一个虚拟地址访问内存，虚拟地址通过**地址翻译**转化为适当的物理地址

![image-20230104212756659](https://cdn.docjerry.top/csapp/image-20230104212756659.png)

## 9.2 地址空间

- **地址空间（address space）**：非负整数地址的有序集合
- **线性地址空间**：地址空间的整数是连续的。为了简化讨论，总是假设是线性的
- **物理地址空间**：由$M$个字节的物理内存组成的地址空间。这里$M$不要求是2的幂
$$
\{0,1,2,...,M-1\}
$$
- **虚拟地址空间**：每个进程由$2^n$个字节组成的虚拟地址空间。其中$n$表示32位或64位系统
$$
\{0,1,2,...,2^n-1\}
$$

## 9.3~9.5 虚拟页

- **虚拟页VP（简称页, `page`）**：虚拟内存分割成固定大小的块。页大小是$P=2^p$字节，Linux中默认是4096字节（`getconf PAGESIZE`）
- **物理页PP（简称页帧, `page frame`）**：物理内存分割成固定大小的块。页帧大小是$P=2^p$字节
- **页表（`Page Table`）**：虚拟页通过页表的数据结构映射到物理页。页表由**页表项（`PTE`, Page Table Entry）** 组成
  - **页表项**：包含页帧地址以及控制位，控制位包含 **有效位(`valid bit`)** 表明当前虚拟页是否被保存在内存中

![image-20230104220838507](https://cdn.docjerry.top/csapp/image-20230104220838507.png)

【说明】图9-4中的虚拟页面如下：

- `VP0`, `VP5`：还未分配

- `VP1`, `VP2`, `VP4`, `VP7`：已分配，缓存在内存中
- `VP3`, `VP6`：已分配，但是被换出到磁盘上，未缓存在内存里

考虑以下操作：

- **页命中**：如果进程访问`VP2`中的虚拟地址。由于**页表项是有效的**，此时页表将`VP2` **翻译**成物理页帧`PP1`，最后构造出物理地址
- **缺页**：如果进程访问`VP3`中的虚拟地址。由于**页表项无效**，所以引发**缺页异常**。此时内核从磁盘将`VP3`的页帧替换到物理内存中(假设位置是`PP3`)，再将`VP3`翻译成`PP3`，最后构造出物理地址
  - **页面调度算法**：磁盘和内存之间，页面如何换入换出，涉及到**页面调度算法**。良好的调度算法遵循**局部性原理**，避免不断地换入换出（**抖动状态**）
- **分配页面**：比如调用`malloc`将在磁盘上创建空间并更新PTE

虚拟页带来的好处：大大简化了内存管理，并提供了一种自然的保护内存的方法

- 简化链接、加载、代码和数据共享
- 提供页面级的内存保护，允许进程读写某个页面（违反则引发**一般保护故障**，即**段错误**）



## 9.6 地址翻译

### 9.6.1 地址翻译基础知识

**页面映射**：虚拟地址根据虚拟页号，从页表找到对应的索引，进而找到对应的物理页号，加上偏移得到物理地址

![image-20230105230023685](https://cdn.docjerry.top/csapp/image-20230105230023685.png)

**页面命中和缺页的操作**

- **页面命中操作**：查询PTE$\to$MMU构造物理地址$\to$返回内存数据给CPU
  - CPU生成一个虚拟地址，并传送给MMU
  - MMU生成PTE地址，并从高速缓存/主存请求得到它
  - 高速缓存/主存向MMU返回PTE
  - MMU构造物理地址，并把它传送给高速缓存/主存
  - 高速缓存/主存返回所请求的数据字给处理器
- **缺页操作**：查询PTE$\to$**缺页中断$\to$调度页面$\to$更新PTE**$\to$再次执行引起缺页的指令$\to$页面命中操作
  - 同页面命中1~3步，查询PTE
  - PTE的有效位是0，引发缺页异常，中断处理缺页异常处理程序
  - **缺页处理程序根据调度算法，将某个页面换入磁盘**
  - **缺页处理程序根据调度算法，将所需页面换入内存，并更新内存中的PTE**
  - 返回到原来的进程，再次执行引起缺页的指令

![image-20230105232015256](https://cdn.docjerry.top/csapp/image-20230105232015256.png)

> [!NOTE]
>
> 地址翻译时，MMU访问主存，中间可以使用L1、L2、L3高速缓存加速

### 9.6.2 TLB

每次CPU产生虚拟地址，MMU就要查询一次PTE。因此MMU使用TLB加速地址翻译

- **`TLB`（Translation Lookaside Buffer, 翻译后备缓冲器）**：一个很小的虚拟寻址缓存，每行保存
- **TLB加速翻译的过程**
  - CPU产生虚拟地址，传送给MMU
  - TLB命中，MMU从TLB取出相应的PTE直接返回；TLB不命中，从L1缓存取出TLB，并刷新TLB
  - 后续流程一致

![image-20230105233240773](https://cdn.docjerry.top/csapp/image-20230105233240773.png)

### 9.6.3 多级页表

【问题】对于32位系统，假设页面大小为4KB，PTE大小占4字节，则总是需要有一个`4MB`的页表主存在内存中，**造成内存空间浪费**。对64位系统会更加复杂
$$
\begin{array}{l}
虚拟地址分为2个部分：虚拟页号(20\ bit)+页面偏移(12\ bit) \\
页表大小=2^{20}*4Byte=4MB
\end{array}
$$
【解决】引入**二级页表**管理。假设页面大小是4KB，PTE大小占4字节。则只有一级页表`4KB`常驻内存 + 常用的二级页表`N*4KB`所占的内存。其它二级页表只有在使用时换入内存，从而**大幅节约内存空间**
$$
\begin{array}{l}
虚拟地址分为3个部分：1级页表页号(10\ bit)+2级页表页号(10\ bit)+页面偏移(12\ bit) \\
1级页表大小=2^{10}*4Byte=4KB \\
2级页表大小=2^{10}*4Byte=4KB
\end{array}
$$

- k级页表的地址翻译原理也是类似的。**使用TLB，保证多级页表的翻译不比一级页表慢很多**

![image-20230105235525372](https://cdn.docjerry.top/csapp/image-20230105235525372.png)

### 9.6.4 地址翻译示例

【例】书中例子，定义以下格式小系统

- 内存按字节寻址（不是4字节的字）
- 页面大小是$2^6=64$字节
- 虚拟地址占14位（虚拟页号8bit + 偏移6bit）
- 物理地址占12位（物理页号8bit + 偏移6bit）
- TLB是四路组相联的，总共有16个条目
- L1缓存是物理寻址、直接映射的，行大小为4字节，总共有16个组

**假设当前TLB、页表项、L1缓存的内容如下：**

![image-20230106205122988](https://cdn.docjerry.top/csapp/image-20230106205122988.png)

**此时访问虚拟地址`0x03d4`，过程如下：**

![image-20230106205231478](https://cdn.docjerry.top/csapp/image-20230106205231478.png)

- **第一阶段**：通过TLB或MMU获取物理页号，得到物理地址
  - 虚拟地址：虚拟页号0x0f、偏移0x14
  - 取PTE：检查TLB。将虚拟页号进一步拆成TLB索引(0x3)和TLB标记(0x3)，有效匹配组0x3的第二个条目，将TLB缓存的0x0D返回MMU
    - 注：如果TLB表项无效，则通过虚拟页号(0xF)在页表中也能找到物理页号是0x0D
  - 物理地址：0xD << 6 + 0x14 = 0x354

![image-20230106205252965](https://cdn.docjerry.top/csapp/image-20230106205252965.png)

- **第二阶段**：L1缓存取出数据
  - 物理地址拆成：缓存标记(0x0d)、缓存组索引(0x5)、缓存偏移(0x0)
  - L1缓存找组0x5，此时标记位0xD且有效位为1表示命中。读出偏移量0x00的数据字节为0x36，返回MMU
  - MMU将0x36返回给CPU



## 9.7 Intel Core i7/Linux内存系统

看一下实际的Intel Core i7的内存系统。其实就是前面几节的扩展

- Core i7包括四个核、所有核共享L3高速缓存和DDR3内存控制器

- 每个核包含一个层次结构的TLB（四路组相联）、一个层次结构的数据和指令高速缓存、一组快速的点到点链路（用于核与其他核和外部IO桥直接通信）
- L1、L2、L3是物理寻址的，块大小为64字节。L1和L2是8路组相联、L3是16路组相联的
- Linux系统页大小启动时默认是4KB

![image-20230108105612111](https://cdn.docjerry.top/csapp/image-20230108105612111.png)

### 9.7.1 地址翻译过程

**最长过程**：CPU访问虚拟地址(VA)$\to$TLB(不命中)$\to$MMU地址翻译(四级页表)$\to$更新TLB$\to$拼接物理地址(PA)$\to$Cache查找结果(不命中)$\to$主存查找结果$\to$更新Cache$\to$返回结果给CPU

![image-20230108105859945](https://cdn.docjerry.top/csapp/image-20230108105859945.png)

**MMU四级页表翻译过程**

![image-20230108112611878](https://cdn.docjerry.top/csapp/image-20230108112611878.png)

- 36位虚拟页号分成4个9位的虚拟页号VPN1~VPN4，分别指向各级页表
- CR3寄存器包含1级页表的物理地址。根据VPN1的索引找到页表项L1 PTE
- L1 PTE包含2级页表的物理地址。根据VPN2的索引找到页表项L2 PTE
- 以此类推，找到物理地址PPN

> [!TIP]
>
> 每当触发上下文切换后，就将CR3寄存器（1级页表基地址）更新为`task_struct->mm->pgd`
>
> MMU每翻译一个虚拟地址时，会更新各级页表的A位（访问位）和D位（修改位），用于页面调度算法



### 9.7.2 Linux虚拟内存系统

**Linux为每个进程各自维护了一个虚拟地址空间，分为内核空间和用户空间**

- **用户空间**：代码、数据、堆、共享库、栈段
- **内核空间**：内核代码和数据、进程相关的数据结构（页表、内核栈）等。注意：**Linux进程的内核空间是共享的，直接映射到一组连续的物理页面**

![image-20230108131603715](https://cdn.docjerry.top/csapp/image-20230108131603715.png)

**虚拟内存的组织**：内核为系统的每个进程维护了一个`task_struct`，内部包含进程的所有信息（PID、用户栈指针、可执行目标文件名、程序计数器、虚拟内存状态等）

- `task_struct->mm`：记录虚拟内存的当前状态。其中，我们关心两个条目：
  - `mm->pgd`：指向第一级页表的基址，上下文切换时会更新CR3寄存器
  - `mm->mmap`：指向`vm_area_structs`的链表，链表的各个节点描述了当前虚拟地址空间的一个区域，指示区域的起始和结束位置、该区域是否具有读写权限、是否是共享的

![image-20230108130344902](https://cdn.docjerry.top/csapp/image-20230108130344902.png)

**Linux缺页异常处理**

- 虚拟地址A是否合法？若不合法，触发段错误，终止进程
- 虚拟地址访问的内存区域是否合法（该区域是否有读写权限）？若不合法，触发段错误，终止进程
- 牺牲一个页面，换入新页面
- CPU重新执行引起缺页的指令



## 9.8 内存映射

> [!NOTE]
>
> 本节内容参考《UNIX系统编程手册》

### 9.8.1~9.8.3 内存映射

调用进程使用`mmap()`，可以在虚拟地址空间中创建一个内存映射。映射分为2种：

- **文件映射**：将一个普通文件的一部分直接映射到进程的虚拟内存中。之后可以读取内存字节操作文件内容。映射的分页在需要时从文件中自动加载
- **匿名映射**：没有对应的文件，映射的分页初始化为0

进程间共享分页是否可见又分2种：

- **共享映射（MAP_SHARED）**：两个进程共享同一个映射区域，其他进程可见。对文件映射来说，变更将发生在底层的文件上。

![image-20230109221614502](https://cdn.docjerry.top/csapp/image-20230109221614502.png)

- **私有映射（MAP_PRIVATE）**：映射内容的变更对其他进程不可见，进程间通过**写时复制(copy-on-write)** 共享
  - **写时复制**：例如发生在`fork()`系统调用时。初始时父子进程共享分页，分页都是只读权限。当有一个进程修改分页内容，在物理内存中创建一个新副本，复制分页内容到新副本中，最后恢复页面的可写权限。CPU在新页面上重新执行写操作

![image-20230109221636823](https://cdn.docjerry.top/csapp/image-20230109221636823.png)

综上所述，内存映射的方式包含四种，用途如下：

|          | 文件映射                         | 匿名映射            |
| -------- | -------------------------------- | ------------------- |
| 私有映射 | 根据文件内容初始化内存           | 内存分配            |
| 共享映射 | 内存映射I/O：进程间共享内存(IPC) | 进程间共享内存(IPC) |

- **私有文件映射**：多个进程初始时使用相同文件初始化，共享相同的内存分页。通过写时复制使得进程对映射做出的改变对其他进程不可见。**用途**：根据二进制可执行文件或共享库文件的相应部分，初始化一个进程的文本和数据段
- **私有匿名映射**：使用`mmap()`创建一个新映射，各进程间不共享分页。**用途**：为一个进程分配用0填充的内存，如使用`mmap()`分配大块内存；`fork()`之后父子进程不会看到对内存分页做出的变更
- **共享文件映射**：进程共享相同的内存物理分页，对分页的修改直接在文件中进行。**用途**：进程间通信
- **共享匿名映射**：发生在父子进程间，映射的分页不采取写时复制，即父子进程共享相同的RAM分页。**用途**：父子进程间通信

> [!TIP]
>
> 再看`fork()`和`execve()`流程
>
> - `fork()`流程
>   - 内核为子进程创建各种数据结构，并分配唯一PID
>   - 将父子进程的**每个页面都标记为只读**，并将进程中的每个区域结构都标记为**私有的写时复制**
>   - 父进程或子进程进行写操作时，**通过写时复制机制，创建新页面**
> - `execve()`流程
>   - 删除子进程已存在的区域结构
>   - 虚拟地址空间中的私有区域：创建新程序的代码、数据、bss和栈（私有映射写时复制）
>   - 虚拟地址空间中的共享区域：动态链接标准C库`libc.so`等动态库（共享映射）
>   - 设置程序计数器PC，指向代码区域的入口点(main函数)

### 9.8.4 mmap函数

- `mmap()`：创建一个新的虚拟内存区域，并将fd指定的磁盘文件映射到这个区域（映射大小是分页大小4K的整数倍，访问映射超出部分将导致段错误）
- `munmap()`：进程终止时，或调用了`munmap`之后，存储映射区就被自动去除。关闭文件描述符fd并不解除映射区

![image-20230109222518279](https://cdn.docjerry.top/csapp/image-20230109222518279.png)

```clike
#include <unistd.h>
#include <sys/mman.h>
//返回：若成功则为指向映射区域的指针，若出错则为MAP_FAILED(-1)
void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
//返回：若成功返回0，出错返回-1
int munmap(void *start, size_t length);
```

【例】《UNIX环境高级编程》例子，使用mmap备份文件，效率在普通read/write之上

```clike
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h> /* mmap() */
#include <fcntl.h>

void err_quit(const char *fmt, ...) {
    va_list args;
    va_start(args, fmt);
    vprintf(fmt, args);
    va_end(args);
    printf("\n");
    exit(0);
}

int main (int argc, char *argv[]) {
    int fdin, fdout;
    char *src, *dst;
    struct stat statbuf;

    if (argc != 3) {
        err_quit("usage: a.out <fromfile> <tofile>");
    }
    /* open the input file */
    if ((fdin = open(argv[1], O_RDONLY)) < 0) {
        err_quit("can't open %s for reading", argv[1]);
    }
    /* create the output file */
    if ((fdout = open(argv[2], O_RDWR | O_CREAT | O_TRUNC, 0777)) < 0) {
        err_quit("can't create %s for writing", argv[2]);
    }
    /* find size of input file */
    if (fstat(fdin, &statbuf) < 0) {
        err_quit("fstat error");
    }
    /* go to the location corresponding to the last byte */
    if (lseek(fdout, statbuf.st_size - 1, SEEK_SET) == -1) {
        err_quit("lseek error");
    }
    /* write a dummy byte at the last location */
    if (write(fdout, "", 1) != 1) {
        err_quit("write error");
    }
    /* mmap the input file */
    if ((src = mmap(0, statbuf.st_size, PROT_READ,
                    MAP_FILE | MAP_SHARED, fdin, 0)) == (caddr_t) -1) {
        err_quit("mmap error for input");
    }
    /* mmap the output file */
    if ((dst = mmap(0, statbuf.st_size, PROT_READ | PROT_WRITE,
                    MAP_FILE | MAP_SHARED, fdout, 0)) == (caddr_t) -1) {
        err_quit("mmap error for output");
    }
    /* this copies the input file to the output file */
    memcpy(dst, src, statbuf.st_size);
    return 0;
}
```

## 9.9 动态内存分配

### 9.9.1~9.9.3 malloc和free函数

动态内存分配：程序运行时需要动态申请虚拟内存，可以在**堆**中申请空间

- **堆（heap）**：视为一组不同大小 **块（block）** 的集合，由**动态内存分配器**显式分配和释放
- `brk指针`：内核维护一个brk指针指向堆顶
- `malloc()`：显式申请块大小，返回的块的地址有字节对齐。32位模式块的地址总是8的倍数；64位总是16的倍数
- `calloc()`：`malloc()`的包装，初始的内存初始化为0
- `realloc()`：改变已分配块的大小
- `sbrk()`：通过修改`brk`指针扩展和收缩堆（incr可以是正数或负数）
- `free()`：释放已分配的堆块

```clike
#include <stdlib.h>
void *malloc(size_t size);
void *sbrk(intptr_t incr);
void free(void *ptr);
```

【例】malloc和free书中例子（假设堆是16字双字对齐，分配器返回的块是8字节双字边界对齐的）

- 申请4字的块。返回块地址`p1`
- 申请5字的块。为了保证空闲块对齐，申请了6块。返回块地址`p2`
- 申请6字的块。返回块地址`p3`
- 释放`p2`的块
- 申请2字的块。返回块地址`p4`

![image-20230112224633760](https://cdn.docjerry.top/csapp/image-20230112224633760.png)

```clike
#include <stdio.h>
#include <stdlib.h>

void* Malloc(size_t size) {
    void *p = malloc(size);
    if (p == NULL) {
        printf("malloc fail\n");
        exit(1);
    }
}

int main() {
    int *p1, *p2, *p3, *p4;
    p1 = (int *)Malloc(4 * sizeof(int));
    p2 = (int *)Malloc(5 * sizeof(int));
    p3 = (int *)Malloc(6 * sizeof(int));
    printf("p1 = %p\n", p1);    //0x5602309b32a0
    printf("p2 = %p\n", p2);    //0x5602309b32c0
    printf("p3 = %p\n", p3);    //0x5602309b32e0
    free(p2);
    p4 = (int *)Malloc(2 * sizeof(int));
    printf("p4 = %p\n", p4);    //0x5602309b32c0
    free(p1);
    free(p3);
    free(p4);
    return 0;
}
```

【说明】

- `malloc()`产生的地址总是对齐的。malloc异常，返回`NULL`并设置`errno`
- 块释放后，新申请的块在空闲处可以重新申请。但是这会带来**碎片**

### 9.9.4~9.9.12 内存管理：隐式空闲链表

- **碎片（fragmentation）**：有未使用的内存，但是不能满足分配请求
  - **内部碎片**：为满足对齐约束，多申请了一块内存（图9-34b）
  - **外部碎片**：空闲内存块不足以申请内存。图9-34e，如果申请8字节内存，只能向内核请求额外的虚拟内存
- **块组织**：为了尽可能避免碎片的产生，分配器需要考虑如何去**记录、分配、分割、合并**空闲块。大多数分配器将分配器记录到块本身，包含：**块头部、有效载荷、填充（可选）**（图9-35）
  - **块头部**：32位，包含块大小(包含头部和所有填充)和标识
    - 标识位：由于块大小是8的倍数，所以低3位用于其它标识位：最低位标识块是否分配
  - **有效载荷**：malloc申请的有效载荷
  - **填充位**：可选项，可能是分配器策略的一部分，用于对抗外部碎片，或满足对齐要求

![image-20230112224707023](https://cdn.docjerry.top/csapp/image-20230112224707023.png)

【例】已分配24(18 bit)字节的块头部

```bash
0x00000018 | 0x1 = 0x00000019
```

**隐式空闲链表**：通过块头部，将堆组织成一个连续的已分配/空闲块的链表。分配器凭此遍历堆中的所有块（图9-36）

- 优点：实现简单
- 缺点1：任何操作都要对链表进行搜索（包含已分配块和空闲块），时间复杂度是线性的
- 缺点2：对最小块大小有要求（块头部+有效载荷，至少16字节）

![image-20230112224736271](https://cdn.docjerry.top/csapp/image-20230112224736271.png)

**分配器的实现**

- `malloc`：寻找空闲块、分割空闲块
  - 寻找空闲块策略
    - 首次适配：从头开始搜索空闲块，选择第一个合适块。*缺点：碎片增加*
    - 下一次适配：从上一次查询结束的地方开始搜索。*缺点：内存利用率低*
    - 最佳适配：检查每个空闲块，选择合适所需请求大小的最小空闲块。*缺点：时间慢*
  - 寻找空闲块失败处理
    - 合并相邻的空闲块，创建更大的空闲块，再次查找
    - 调用`sbrk`函数，向内核请求额外的堆内存
  - 分割空闲块
    - 方案一：分配整个空闲块出去。*缺点：会产生内部碎片*
    - 方案二：空闲块分割成两个部分，将一部分分配出去，另一部分作为新空闲块
- `free`：释放块、合并空闲块
  - 释放块：将当前块的标志设置为空闲
  - 合并空闲块策略
    - 立即合并：每次块释放就进行合并操作
    - 推迟合并：例如某个分配请求失败，再扫描整个堆合并所有空闲块
  - 合并的实现：使用**边界标记**合并，每个块的尾部增加一个**脚部（footer）**，判断相邻块是否空闲（图9-40）
    - 情况1：前块和后块都是已分配的。此时只需设置当前块标志为空闲即可。
    - 情况2：前块已分配，后块空闲。当前块需要和后块合并，更新块大小
    - 情况3：前块空闲，后块已分配。当前块需要和前块合并，更新块大小
    - 情况4：前块和后块都是空闲的。当前块需要和前后块合并，更新块大小

![image-20230112224759246](https://cdn.docjerry.top/csapp/image-20230112224759246.png)
![image-20230112224857533](https://cdn.docjerry.top/csapp/image-20230112224857533.png)

### 9.9.13 内存管理：显式空闲链表

**显式空闲链表**：块有效载荷增加`pred`和`succ`指针，显式地将所有空闲块串联，形成双向显式空闲链表

- **优点**：只遍历所有空闲块，无需遍历已分配块
- **缺点**：增加了最小块大小要求（块头部+有效载荷+`pred`+`succ`指针）

![image-20230112224929614](https://cdn.docjerry.top/csapp/image-20230112224929614.png)

**显式空闲链表组织**

- LIFO顺序：释放块插入空闲链表开始处 *（使用LIFO+首次适配分配+边界标记合并，可以在常数时间分配和合并块）*
- 地址顺序：按地址顺序安排空闲块链表，从低到高排序

### 9.9.14 分离的空闲链表

使用单个空闲链表去查找空闲块，效率较低（线性）。可以使用有组织的多个空闲链表用于加速搜索效率（空间换时间）

例如：可以按照2的幂，将块按大小划分成几组等价类（也称**大小类**）：

```bash
{1},{2},{3,4},{5~8},...,{1025~2048},...
```

分配器中维护这些大小类的链表。当分配器需要一个大小为$n$的块时，搜索对应的链表。如果不能找到合适的块，就向上搜索块大小更大的链表

- **伙伴系统（buddy system）**：每个大小类都是2的幂。请求的块大小**向上舍入到最接近2的幂大小**
  - **块申请**：假设申请$2^k$的块。如果从空闲链表找到合适大小的块，则完成块申请。如果没有找到，则递归搜索块大小更大的链表。此时找到空闲块后，将内存块分成两部分（也叫**伙伴**）：一半放到下一级空闲链表中；另一半继续递归往下分割，直至分解到合适大小的块，完成块申请。
  - **块释放**：内核将伙伴递归合并为更大的内存块放回到伙伴列表中，即内存块分裂的逆过程
  - **好处**：分配器能够进行快速搜索和快速合并，很容易找到一个内存块的伙伴位置
  - **缺点**：要求块大小是2的幂，可能会导致显著的内部碎片

> [!TIP]
>
> 对于比较小的内存的申请，可以使用slab分配器进行分配

## 9.10 垃圾收集

内存可以视为一张有向可达图(`reachability graph`)。图中节点分为一组根节点和一组堆节点，每个堆节点对应堆中的一个分配块。

![image-20230112225002859](https://cdn.docjerry.top/csapp/image-20230112225002859.png)

- **节点可达**：存在一条从任意根节点到达节点$p$的有向路径，即该内存可以被应用再次使用
- **节点不可达**：不存在到达节点$p$的有向路径，即所谓的**垃圾**
- **垃圾收集器**：根据平衡树，定期标记、收集和释放不在需要的已分配块。

> [!TIP]
>
> 本节讲述的比较简单，详细可以参考《深入理解Java虚拟机》

## 9.11 C程序中常见的内存有关错误

【例】间接引用坏指针

```clike
//scanf("%d", val);   //错误：把val解释为一个地址，试图将数值写入该地址
scanf("%d", &val);    //正确
```

【例】读未初始化的内存

```clike
int *sum_array(int *arr, int n) {
    int i;
    int *sum = (int *)malloc(sizeof(int));  //错误：*x的初值不一定是0，需赋初值
    printf("%d\n", *sum);
    for (i = 0; i < n; i++) {
        *sum += arr[i];
    }
    return sum;
}
```

【例】缓冲区溢出错误

```clike
char buf[64];
gets(buf);      //错误：缓冲区溢出问题，必须使用fgets函数
```

【例】假设指针和对象大小相同

```clike
int** make_array(int n, int m) {
    int i;
    int **arr = (int **)malloc(n * sizeof(int));
    for (i = 0; i < n; i++) {
        arr[i] = (int *)malloc(m * sizeof(int));    //错误：应该是sizeof(int*)
    }
    return arr;
}
```

【例】造成错位错误，数组越界错误

```clike
int** make_array(int n, int m) {
    int i;
    int **arr = (int **)malloc(n * sizeof(int));
    for (i = 0; i <= n; i++) {                      //错误：i不能等于n，否则越界错误
        arr[i] = (int *)malloc(m * sizeof(int));
    }
    return arr;
}
```

【例】引用指针而不是对象

```clike
int *binheapDelete(int **binheap, int *size) {
    int *packet = binheap[0];
    binheap[0] = binheap[*size - 1];
    *size--;                   //这里应该是(*size)--，注意运算符的结合
    heapify(binheap, *size, 0);
    return packet;
}
```

【例】误解指针运算

```clike
int *search(int *p, int val) {
    while (*p && *p != val) {
        p += sizeof(int);      //这里应该是p++，因为p+1相当于指针加4
    }
    return p;
}
```

【例】引用不存在的变量

```clike
int *stackref() {
    int val;
    return &val;    //错误：函数返回后局部变量val被释放
}
```

【例】引用空闲堆块中的数据

```clike
int *heapref(int n, int m) {
    int i;
    int *x, *y;
    x = (int *)malloc(n * sizeof(int));
......
    //Other calls to malloc and free go here
    free(x);
......
    y = (int *)malloc(m * sizeof(int));
    for(i = 0; i < m; i++){
        y[i] = x[i]++;       //错误：引用了空闲块*x
    }
    return y;
}
```

【例】内存泄漏

```clike
void leak(int n) {
    int *x = (int *)malloc(n * sizeof(int));    //错误：未释放*x
    return;
}
```
