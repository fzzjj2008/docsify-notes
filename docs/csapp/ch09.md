# ch09 虚拟内存

## 9.1 物理和虚拟寻址

- **物理地址**：计算机的主存被组织成连续的字节单元组成的数组。每个字节都有唯一的物理地址
- **物理寻址**：CPU使用物理地址直接访问内存的方式
- **虚拟地址**：主存进行抽象，为每个进程提供大小一致的、私有的地址空间
- **虚拟寻址**：CPU通过一个虚拟地址访问内存，虚拟地址通过**地址翻译**转化为适当的物理地址

![image-20230104212756659](https://cdn.docjerry.top/csapp/image-20230104212756659.png)

## 9.2 地址空间

- **地址空间(address space)**：非负整数地址的有序集合
- **线性地址空间**：地址空间的整数是连续的。为了简化讨论，总是假设是线性的
- **物理地址空间**：由$M$个字节的物理内存组成的地址空间。这里$M$不要求是2的幂
$$
\{0,1,2,...,M-1\}
$$
- **虚拟地址空间**：每个进程由$2^n$个字节组成的虚拟地址空间。其中$n$表示32位或64位系统
$$
\{0,1,2,...,2^n-1\}
$$

## 9.3~9.5 页面概述

- **虚拟页VP（简称页, page）**：虚拟内存分割成固定大小的块。页大小是$P=2^p$字节，Linux中默认是4096字节（`getconf PAGESIZE`）
- **物理页PP（简称页帧, page frame）**：物理内存分割成固定大小的块。页帧大小是$P=2^p$字节
- **页表（Page Table）**：虚拟页通过页表的数据结构映射到物理页。页表由**页表项（PTE, Page Table Entry）** 组成
  - **页表项**：包含页帧地址以及控制位，控制位包含 **有效位(valid bit)** 表明当前虚拟页是否被保存在内存中

![image-20230104220838507](https://cdn.docjerry.top/csapp/image-20230104220838507.png)

【说明】图9-4中的虚拟页面如下：

- `VP0`, `VP5`：还未分配

- `VP1`, `VP2`, `VP4`, `VP7`：已分配，缓存在内存中
- `VP3`, `VP6`：已分配，但是被换出到磁盘上，未缓存在内存里

考虑以下操作：

- **页命中**：如果进程访问`VP2`中的虚拟地址。由于**页表项是有效的**，此时页表将`VP2` **翻译**成物理页帧`PP1`，最后构造出物理地址
- **缺页**：如果进程访问`VP3`中的虚拟地址。由于**页表项无效**，所以引发**缺页异常**。此时内核从磁盘将`VP3`的页帧替换到物理内存中(假设位置是`PP3`)，再将`VP3`翻译成`PP3`，最后构造出物理地址
  - **页面调度算法**：磁盘和内存之间，页面如何换入换出，涉及到**页面调度算法**。良好的调度算法遵循**局部性原理**，避免不断地换入换出（**抖动状态**）
- **分配页面**：比如调用`malloc`将在磁盘上创建空间并更新PTE

虚拟页带来的好处：大大简化了内存管理，并提供了一种自然的保护内存的方法

- 简化链接、加载、代码和数据共享
- 提供页面级的内存保护，允许进程读写某个页面（违反则引发**一般保护故障**，即**段错误**）



## 9.6 地址翻译

### 9.6.1 地址翻译基础知识

**页面映射**：虚拟地址根据虚拟页号，从页表找到对应的索引，进而找到对应的物理页号，加上偏移得到物理地址

![image-20230105230023685](https://cdn.docjerry.top/csapp/image-20230105230023685.png)

**页面命中和缺页的操作**

- **页面命中操作**：查询PTE$\to$MMU构造物理地址$\to$返回内存数据给CPU
  - CPU生成一个虚拟地址，并传送给MMU
  - MMU生成PTE地址，并从高速缓存/主存请求得到它
  - 高速缓存/主存向MMU返回PTE
  - MMU构造物理地址，并把它传送给高速缓存/主存
  - 高速缓存/主存返回所请求的数据字给处理器
- **缺页操作**：查询PTE$\to$**缺页中断$\to$调度页面$\to$更新PTE**$\to$再次执行引起缺页的指令$\to$页面命中操作
  - 同页面命中1~3步，查询PTE
  - PTE的有效位是0，引发缺页异常，中断处理缺页异常处理程序
  - **缺页处理程序根据调度算法，将某个页面换入磁盘**
  - **缺页处理程序根据调度算法，将所需页面换入内存，并更新内存中的PTE**
  - 返回到原来的进程，再次执行引起缺页的指令

![image-20230105232015256](https://cdn.docjerry.top/csapp/image-20230105232015256.png)

> [!NOTE]
>
> 地址翻译时，MMU访问主存，中间可以使用L1、L2、L3高速缓存加速

### 9.6.2 TLB

每次CPU产生虚拟地址，MMU就要查询一次PTE。因此MMU使用TLB加速地址翻译

- **TLB（Translation Lookaside Buffer, 翻译后备缓冲器）**：一个很小的虚拟寻址缓存，每行保存
- **TLB加速翻译的过程**
  - CPU产生虚拟地址，传送给MMU
  - TLB命中，MMU从TLB取出相应的PTE直接返回；TLB不命中，从L1缓存取出TLB，并刷新TLB
  - 后续流程一致

![image-20230105233240773](https://cdn.docjerry.top/csapp/image-20230105233240773.png)

### 9.6.3 多级页表

【问题】对于32位系统，如果页面大小为4KB，PTE大小占4字节，则总是需要有一个`4MB`的页表主存在内存中，**造成内存空间浪费**。对64位系统会更加复杂
$$
\begin{array}{l}
虚拟地址分为2个部分：虚拟页号(20\ bit)+页面偏移(12\ bit) \\
页表大小=2^{20}*4Byte=4MB
\end{array}
$$
【解决】引入**二级页表**管理。假设页面大小是4KB，PTE大小占4字节。则只有一级页表`4KB`常驻内存，最常用的二级页表`N*4KB`常驻内存，其它只有在分配使用时换入内存。从而**大幅节约内存**
$$
\begin{array}{l}
虚拟地址分为3个部分：1级页表页号(10\ bit)+2级页表页号(10\ bit)+页面偏移(12\ bit) \\
1级页表大小=2^{10}*4Byte=4KB \\
2级页表大小=2^{10}*4Byte=4KB
\end{array}
$$

- k级页表的地址翻译原理也是类似的。**使用TLB保证多级页表的翻译不比一级页表慢很多**

![image-20230105235525372](https://cdn.docjerry.top/csapp/image-20230105235525372.png)

### 9.6.4 地址翻译示例



## 9.7 页表

- 页表条目格式
- 

