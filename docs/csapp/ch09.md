# ch09 虚拟内存

## 9.1 物理和虚拟寻址

- **物理地址**：计算机的主存被组织成连续的字节单元组成的数组。每个字节都有唯一的物理地址
- **物理寻址**：CPU使用物理地址直接访问内存的方式
- **虚拟地址**：主存进行抽象，为每个进程提供大小一致的、私有的地址空间
- **虚拟寻址**：CPU通过一个虚拟地址访问内存，虚拟地址通过**地址翻译**转化为适当的物理地址

![image-20230104212756659](https://cdn.docjerry.top/csapp/image-20230104212756659.png)

## 9.2 地址空间

- **地址空间(address space)**：非负整数地址的有序集合
- **线性地址空间**：地址空间的整数是连续的。为了简化讨论，总是假设是线性的
- **物理地址空间**：由$M$个字节的物理内存组成的地址空间。这里$M$不要求是2的幂
$$
\{0,1,2,...,M-1\}
$$
- **虚拟地址空间**：每个进程由$2^n$个字节组成的虚拟地址空间。其中$n$表示32位或64位系统
$$
\{0,1,2,...,2^n-1\}
$$

## 9.3~9.5 页面概述

- **虚拟页VP（简称页, page）**：虚拟内存分割成固定大小的块。页大小是$P=2^p$字节，Linux中默认是4096字节（`getconf PAGESIZE`）
- **物理页PP（简称页帧, page frame）**：物理内存分割成固定大小的块。页帧大小是$P=2^p$字节
- **页表（Page Table）**：虚拟页通过页表的数据结构映射到物理页。页表由**页表项（PTE, Page Table Entry）** 组成
  - **页表项**：包含页帧地址以及控制位，控制位包含 **有效位(valid bit)** 表明当前虚拟页是否被保存在内存中

![image-20230104220838507](https://cdn.docjerry.top/csapp/image-20230104220838507.png)

【说明】图9-4中的虚拟页面如下：

- `VP0`, `VP5`：还未分配

- `VP1`, `VP2`, `VP4`, `VP7`：已分配，缓存在内存中
- `VP3`, `VP6`：已分配，但是被换出到磁盘上，未缓存在内存里

考虑以下操作：

- **页命中**：如果进程访问`VP2`中的虚拟地址。由于**页表项是有效的**，此时页表将`VP2` **翻译**成物理页帧`PP1`，最后构造出物理地址
- **缺页**：如果进程访问`VP3`中的虚拟地址。由于**页表项无效**，所以引发**缺页异常**。此时内核从磁盘将`VP3`的页帧替换到物理内存中(假设位置是`PP3`)，再将`VP3`翻译成`PP3`，最后构造出物理地址
  - **页面调度算法**：磁盘和内存之间，页面如何换入换出，涉及到**页面调度算法**。良好的调度算法遵循**局部性原理**，避免不断地换入换出（**抖动状态**）
- **分配页面**：比如调用`malloc`将在磁盘上创建空间并更新PTE

虚拟页带来的好处：大大简化了内存管理，并提供了一种自然的保护内存的方法

- 简化链接、加载、代码和数据共享
- 提供页面级的内存保护，允许进程读写某个页面（违反则引发**一般保护故障**，即**段错误**）



## 9.6 地址翻译

### 9.6.1 地址翻译基础知识

**页面映射**：虚拟地址根据虚拟页号，从页表找到对应的索引，进而找到对应的物理页号，加上偏移得到物理地址

![image-20230105230023685](https://cdn.docjerry.top/csapp/image-20230105230023685.png)

**页面命中和缺页的操作**

- **页面命中操作**：查询PTE$\to$MMU构造物理地址$\to$返回内存数据给CPU
  - CPU生成一个虚拟地址，并传送给MMU
  - MMU生成PTE地址，并从高速缓存/主存请求得到它
  - 高速缓存/主存向MMU返回PTE
  - MMU构造物理地址，并把它传送给高速缓存/主存
  - 高速缓存/主存返回所请求的数据字给处理器
- **缺页操作**：查询PTE$\to$**缺页中断$\to$调度页面$\to$更新PTE**$\to$再次执行引起缺页的指令$\to$页面命中操作
  - 同页面命中1~3步，查询PTE
  - PTE的有效位是0，引发缺页异常，中断处理缺页异常处理程序
  - **缺页处理程序根据调度算法，将某个页面换入磁盘**
  - **缺页处理程序根据调度算法，将所需页面换入内存，并更新内存中的PTE**
  - 返回到原来的进程，再次执行引起缺页的指令

![image-20230105232015256](https://cdn.docjerry.top/csapp/image-20230105232015256.png)

> [!NOTE]
>
> 地址翻译时，MMU访问主存，中间可以使用L1、L2、L3高速缓存加速

### 9.6.2 TLB

每次CPU产生虚拟地址，MMU就要查询一次PTE。因此MMU使用TLB加速地址翻译

- **TLB（Translation Lookaside Buffer, 翻译后备缓冲器）**：一个很小的虚拟寻址缓存，每行保存
- **TLB加速翻译的过程**
  - CPU产生虚拟地址，传送给MMU
  - TLB命中，MMU从TLB取出相应的PTE直接返回；TLB不命中，从L1缓存取出TLB，并刷新TLB
  - 后续流程一致

![image-20230105233240773](https://cdn.docjerry.top/csapp/image-20230105233240773.png)

### 9.6.3 多级页表

【问题】对于32位系统，假设页面大小为4KB，PTE大小占4字节，则总是需要有一个`4MB`的页表主存在内存中，**造成内存空间浪费**。对64位系统会更加复杂
$$
\begin{array}{l}
虚拟地址分为2个部分：虚拟页号(20\ bit)+页面偏移(12\ bit) \\
页表大小=2^{20}*4Byte=4MB
\end{array}
$$
【解决】引入**二级页表**管理。假设页面大小是4KB，PTE大小占4字节。则只有一级页表`4KB`常驻内存 + 常用的二级页表`N*4KB`所占的内存。其它二级页表只有在使用时换入内存，从而**大幅节约内存空间**
$$
\begin{array}{l}
虚拟地址分为3个部分：1级页表页号(10\ bit)+2级页表页号(10\ bit)+页面偏移(12\ bit) \\
1级页表大小=2^{10}*4Byte=4KB \\
2级页表大小=2^{10}*4Byte=4KB
\end{array}
$$

- k级页表的地址翻译原理也是类似的。**使用TLB保证多级页表的翻译不比一级页表慢很多**

![image-20230105235525372](https://cdn.docjerry.top/csapp/image-20230105235525372.png)

### 9.6.4 地址翻译示例

【例】书中例子，定义以下格式小系统

- 内存按字节寻址（不是4字节的字）
- 页面大小是$2^6=64$字节
- 虚拟地址占14位（虚拟页号8bit + 偏移6bit）
- 物理地址占12位（物理页号8bit + 偏移6bit）
- TLB是四路组相联的，总共有16个条目
- L1缓存是物理寻址、直接映射的，行大小为4字节，总共有16个组

**假设当前TLB、页表项、L1缓存的内容如下：**

![image-20230106205122988](https://cdn.docjerry.top/csapp/image-20230106205122988.png)

**此时访问虚拟地址`0x03d4`，过程如下：**

![image-20230106205231478](https://cdn.docjerry.top/csapp/image-20230106205231478.png)

- **第一阶段**：通过TLB或MMU获取物理页号，得到物理地址
  - 虚拟地址：虚拟页号0x0f、偏移0x14
  - 取PTE：检查TLB。将虚拟页号进一步拆成TLB索引(0x3)和TLB标记(0x3)，有效匹配组0x3的第二个条目，将TLB缓存的0x0D返回MMU
    - 注：如果TLB表项无效，则通过虚拟页号(0xF)在页表中也能找到物理页号是0x0D
  - 物理地址：0xD << 6 + 0x14 = 0x354

![image-20230106205252965](https://cdn.docjerry.top/csapp/image-20230106205252965.png)

- **第二阶段**：L1缓存取出数据
  - 物理地址拆成：缓存标记(0x0d)、缓存组索引(0x5)、缓存偏移(0x0)
  - L1缓存找组0x5，此时标记位0xD且有效位为1表示命中。读出偏移量0x00的数据字节为0x36，返回MMU
  - MMU将0x36返回给CPU



## 9.7 Intel Core i7/Linux内存系统

- 页表条目格式
- 



## 9.8 内存映射

