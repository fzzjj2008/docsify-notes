# ch01 温故而知新

## 1.1 从Hello World说起

```clike
#include <stdio.h>

int main()
{
    printf("Hello World\n");
    return 0;
}
```

对于最简单的C程序，作者提出的一些问题，供读者思考：

- Hello World程序从C语言编译成机器码，**编译器做了什么**
- Hello World程序编译出来的**可执行文件里面有什么内容**
- Hello World程序是怎么运行起来的，**操作系统是怎么装载运行它的，运行后在内存中是什么样的**
- **每一句话的原理**
  - `#include <stdio.h>`有什么含义，结合C库是怎么实现的
  - `main()`函数前后发生了什么
  - `printf`是怎么实现的，为什么能输出字符串



## 1.2 计算机硬件的发展

- 现代计算机遵循冯诺依曼体系结构，核心：**CPU、内存、IO设备**
- 早期计算机硬件结构简单，各个设备（CPU、内存、硬盘、显示器、键盘等）有一个IO控制器，各个设备直接连接在**总线`bus`**上
- 后期CPU处理频率提升，为了协调CPU、内存、高速图形设备，专门设计了**北桥芯片**（PCI Bridge，处理高速设备）和**南桥芯片**（ISA Bridge，处理低速设备）
- 为了增加CPU的速度，出现了**对称多处理器（SMP）**。每个CPU功能一致，相互对称。但是多个处理器成本较高，简化版本是**多核处理器（Multi-core Processor）**，一个CPU保留多个核心



## 1.3 计算机系统软件体系架构

![image-20231028164444286](F:\notes\docs\basics\linker_loader\image-20231028164444286.png)

- **分层结构**：硬件层、操作系统层、运行库、应用软件
- **接口（Interface）**：承上启下，对下层包装和扩展，各个层保持相对独立
- **系统调用（System call）**：由操作系统提供的统一接口，以软中断形式提供（int 0x80）



## 1.4 操作系统

### 1.4.1 多任务系统

- **一个CPU资源只能同时跑一个程序**，操作系统支持**分时**跑多个任务
- 应用程序以**进程（Process）**的方式运行。每个进程有独立的地址空间，进程间相互隔离
- 进程的运行：每个进程跑完一段**时间片**，切换到下一进程
- 抢占式分配：操作系统可以强制剥夺CPU资源分配给最需要的进程（**中断**）
- CPU在多个进程间快速切换，造成很多进程都在同时运行的假象

### 1.4.2 设备驱动

- 操作系统开发者为硬件生产厂商提供了一系列接口和框架，凡是按照这个接口和框架的驱动程序都可以在操作系统上使用。以读取文件为例：
  - 有个文件test.dat，长度8000字节，存储在1000\~1007号扇区、2000\~2007号扇区（每扇区512B）
  - 应用程序发出read系统调用，读取test.dat文件
  - 文件系统判断文件的扇区位置，向硬盘驱动器发出读取1000号开始的8个扇区的请求
  - 硬盘驱动器收到请求，向硬盘发出硬件IO命令（寄存器指令in out）
  - 硬盘收到指令后，执行操作，并将数据读到事先设置好的内存中



## 1.5 内存

### 1.5.1 进程内存隔离

- **物理地址空间**：物理内存范围

- **虚拟地址空间**：为了方便每个进程管理自己的内存，每个进程拥有自己独立的虚拟空间（32位主机是0~2^32^，即4GB）。
- 操作系统维护一套**内存映射的算法**，将不同进程的虚拟地址映射到物理地址，保证每个程序访问的物理内存区域与另一个程序不重叠，达到进程地址空间隔离的效果

### 1.5.2 分段（早期）

![image-20231028164419288](F:\notes\docs\basics\linker_loader\image-20231028164419288.png)

- 程序A和程序B被映射到两个不同的物理区域，没有任何重叠。如果访问空间超出范围，则段错误
- 优点：地址空间隔离、程序不需要关心地址重定位问题
- 缺点：内存使用效率低，以程序为单位



### 1.5.3 分页

![image-20231028164343733](F:\notes\docs\basics\linker_loader\image-20231028164343733.png)

- **页映射**：把地址空间分成固定大小的页（通常是4KB）。按一定的规则将虚拟地址页映射到物理地址页
- MMU：为了加速映射，CPU内部集成了一个MMU的硬件实现转换
- **交换（Swap）**：常用数据和代码页装载到内存，不常用装载在磁盘。缺页时产生Page Fault，以页为单位存取和交换数据
- 保护：每个页可以设置权限属性（可读、可写等）

- 优点：相比分段，显著提升内存的使用效率



## 1.6 线程

### 1.6.1 线程基础

- 线程：程序执行流的最小单元。包含线程ID、程序指令指针PC、寄存器集合、堆栈

- 与进程关系：一个进程由多个线程组成，各个线程可共享程序的内存空间和进程资源（fd、信号、全局变量、静态变量、程序代码）
- 线程状态：运行、就绪、等待

![image-20231028165857965](F:\notes\docs\basics\linker_loader\image-20231028165857965.png)

- 线程调度：CFS调度、RT调度
- 线程分类：CPU密集型线程、IO密集性线程；可抢占线程、不可抢占线程
- Linux多线程相关的系统调用：fork、exec、clone
- 写时复制（Copy-on-Write）
  - fork：复制父进程的进程地址空间页表到子进程，那么父子进程就共享相同的物理内存
  - exec：当父子进程中有一方需要修改某个物理页面的内容时，触发写保护的缺页中断，然后才复制共享页面的内容，从而使父子进程拥有各自的副本

### 1.6.2 线程安全

- 竞争和原子：多个线程同时访问一个共享数据，则可能导致意想不到的后果
  - 本质：操作编译为汇编代码不止一条指令，可能执行调度一半杯操作系统打断
- 同步与锁：为了避免竞争，对统一共享数据操作需要加锁
  - 二元信号量（互斥锁）：最简单的锁，只有占用、非占用两种状态
  - 多元信号量（信号量）：PV操作
  - 读写锁：读共享、写独占
  - 条件变量：线程等待条件变量（wait）、线程唤醒条件变量（notify）
- 可重入函数：函数被重入执行后没有任何不良后果
  - 函数不带静态、全局的非const变量
  - 不返回静态、全局的非const变量指针
  - 仅依赖调用方提供的参数
  - 不依赖单个资源的锁
  - 不调用不可重入的函数
- 过度优化：编译器为了提升代码效率可能交换指令的顺序。可使用`volatile`关键字、`barrier`指令阻止优化

### 1.6.3 多线程内部情况

对于windows和linux，都是在内核里提供线程的支持。多线程内部实现的模型有：

- 一对一模型：一个用户进程对应一个内核线程。内核限制了线程数，线程上下文切换开销较大，执行效率下降
- 多对一模型：一个内核进程包含多个用户线程，用户线程的切换需要由用户态代码进行。问题是一个用户线程阻塞则所有线程页阻塞
- 多对多模型：上述两者结合
